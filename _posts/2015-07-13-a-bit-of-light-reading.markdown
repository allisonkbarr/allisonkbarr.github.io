---
layout: post
title:  "A Bit of Light Reading"
date:   2015-07-13 18:53:33 +0100
categories:
---
At my husband's advice, after finding myself frustrated with the online code school programs I tried, I have picked up a few books to help me in my quest to learn computer programming.  Out of the many, many programming books he had or recommended, I chose 3 to make the recent journey with me on our cross-country drive from California to Connecticut.

The first book I've been working my way through is <strong><a href="http://www.amazon.com/gp/product/1593275846/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1593275846&amp;linkCode=as2&amp;tag=alkebaliby-20&amp;linkId=ZE54PGROD753UKYF">Eloquent JavaScript: A Modern Introduction to Programming</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=alkebaliby-20&amp;l=as2&amp;o=1&amp;a=1593275846" width="1" height="1" border="0" alt="" style="border:none !important;margin:0!important;" /></strong>.  This book is challenging for me - I would say it's not aimed at true beginners.  For instance, a chapter that seems at first to be about data structures, throws the math-heavy concept of statistical correlation at you after a few pages.  At this point, though, I suppose I'm no longer a complete beginner, and I am learning a lot from the book, if a bit more slowly than I'm used to.

My next goal in the book is to read a bit more about objects in <a href="http://eloquentjavascript.net/06_object.html" target="_blank">Chapter 6: The Secret Life of Objects</a>, and then work on the project in <a href="http://eloquentjavascript.net/07_elife.html" target="_blank">Chapter 7: Project: Electronic Life.</a> As the author says, "Our project in this chapter is to build a virtual ecosystem, a little world populated with critters that move around and struggle for survival."  Sounds pretty awesome.

The second book, which I just picked up a few days ago, is <strong><a href="http://www.amazon.com/gp/product/0789753391/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0789753391&amp;linkCode=as2&amp;tag=alkebaliby-20&amp;linkId=WEMNZI2AFNEOHZHU">Learning to Program</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=alkebaliby-20&amp;l=as2&amp;o=1&amp;a=0789753391" width="1" height="1" border="0" alt="" style="border:none !important;margin:0!important;" /></strong>. I had been craving a book that would help me catch up with some concepts and theories one would learn in a CS-101 class that I will be missing as a self-taught programmer. So far I have found this book very easy to read - it is definitely written for a beginner - but also useful in reviewing some concepts and elaborating on others. A few points I learned in my first day of reading:
<ul>
	<li>The differences between and pros/cons of compiled and interpreted languages - the author makes a very instructive comparison with sheet music and player pianos.  Compiled languages must be recompiled each time a change is made, which is time consuming, but offers a level of error-checking not included with an interpreted language (like a player piano with its special perforated paper roll). An interpreted language can be changed on the fly, but must be reinterpreted each time it is run (like a musician with sheet music and a regular piano).</li>
	<li>The concept of the runtime environment. Continuing with the piano analogy - if your run-time environment is a regular piano, not a player piano, it does not have the software and/or hardware necessary to read and run the program (perforated paper roll).
	<li>The concept of programming languages as software. Javascript works with web browsers because it is included with them, but for other languages, you need to actually install the language on your computer. This didn't make sense to me the first time I heard it (from my husband a few months ago), but having done a bit more reading now about how programming languages and computers work, it does.  An easier way for me to think about it is that when you install the language on the computer, what you're installing is actually the ability for the computer to compile something written in that language into a language it already understands.
	<li>Some programming languages are "general purpose," while others are specialized for different use cases. For example, Perl is particularly useful when dealing with large amounts of text; R is a language used especially for handling statistical data.</li>
</ul>

The last book I chose to take with me on our travels, though I haven't opened it in a while, is <strong><a href="http://www.amazon.com/gp/product/0262510871/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0262510871&amp;linkCode=as2&amp;tag=alkebaliby-20&amp;linkId=B5ARWOZ5ROWHD4J3">Structure and Interpretation of Computer Programs - 2nd Edition (MIT Electrical Engineering and Computer Science)</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=alkebaliby-20&amp;l=as2&amp;o=1&amp;a=0262510871" width="1" height="1" border="0" alt="" style="border:none !important;margin:0!important;" /></strong>.  I had fun learning about electrical circuits in this book when I was last reading it.  Maybe I'll crack it open again soon.

Coming back to my issue with online code schools for a moment - in a nutshell, my problem with the schools I tried - I was primarily using Codecademy and Treehouse - is that there is too much handholding. No one is going to learn how to actually think and solve problems like a programmer when they are just being asked to regurgitate. For example, the Treehouse course teaching CSS would have an instructor in a video adjust some CSS properties - give an element a width of 100px, border of 1px solid white, etc. - and then in the quiz at the end of the video, it would have you do literally exactly the same thing - width of 100px, border of 1px solid white, etc. No opportunity for creativity, no exploration of other possibilities, and definitely no problem solving.

Oof.

Reading these books has been much more enjoyable for me, and I've supplemented it with some exercises in writing simple programs that I imagine one might encounter in an intro comp sci class or a programming job interview.

Like:
<ul>
	<li>A simple to-do web app - still planning to develop this one further, and perhaps will write more about it another day.</li>
	<li>Find and output an array of all the numbers in the Fibonacci sequence up to <em>n</em>.</li>
	<li>A similar program to the above, but for prime numbers instead of Fibonacci numbers.</li>
	<li>Simulating stack and heap memory using an array - I will likely also do more with this in the future, and will write more about it.</li>
</ul>

Also among my new projects - we bought a Raspberry Pi today!  More on that to come.
